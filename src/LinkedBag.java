/** * A class of bags whose entries are stored in a chain of linked nodes. * The bag is never full. * * @author Frank M. Carrano * @version 2/11/2020 */public class LinkedBag<T extends Comparable<? super T>> implements BagInterface<T>{    private Node<T> firstNode;       // reference to first node    public LinkedBag()    {        this.firstNode = null;    } // end default constructor    /**     * Adds a new entry to this bag.     *     * @param newEntry the object to be added as a new entry     * @return true     */    public boolean add(T newEntry) // OutOfMemoryError possible    {        // add to beginning of chain:        Node<T> newNode = new Node<>(newEntry);        newNode.next = this.firstNode;  // make new node reference rest of chain                                        // (firstNode is null if chain is empty)        this.firstNode = newNode;       // new node is at beginning of chain        return true;    } // end add    /**     * Retrieves all entries that are in this bag.     *     * @return a newly allocated array of all the entries in the bag     */    public T[] toArray()    {        // the cast is safe because the new array contains null entries        int counter = 0;        Node<T> currentNode = this.firstNode;        while (currentNode != null)        {            counter++;            currentNode = currentNode.next;        }        T[] result = (T[]) new Comparable<?>[counter]; // unchecked cast        int index = 0;        currentNode = this.firstNode;        while ((index < result.length) && (currentNode != null))        {            result[index] = currentNode.data;            index++;            currentNode = currentNode.next;        }        return result;    } // end toArray    /**     * Sees whether this bag is empty.     *     * @return true if the bag is empty, or false if not     */    public boolean isEmpty()    {        return this.firstNode == null;    } // end isEmpty    /**     * Gets the number of entries currently in this bag.     *     * @return the integer number of entries currently in the bag     */    public int getCurrentSize()    {        throw new UnsupportedOperationException();    } // end getCurrentSize    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry the entry to be counted     * @return the number of times anEntry appears in the bag     */    public int getFrequencyOf(T anEntry)    {        int frequency = 0;        Node<T> currentNode = this.firstNode;        while (currentNode != null)        {            if (anEntry.equals(currentNode.data))            {                frequency++;            }            currentNode = currentNode.next;        }        return frequency;    } // end getFrequencyOf    /**     * Tests whether this bag contains a given entry.     *     * @param anEntry the entry to locate     * @return true if the bag contains anEntry, or false otherwise     */    public boolean contains(T anEntry)    {        return getReferenceTo(anEntry) != null;    } // end contains    // Locates a given entry within this bag.    // Returns a reference to the node containing the entry, if located,    // or null otherwise.    private Node<T> getReferenceTo(T anEntry)    {        boolean found = false;        Node<T> currentNode = this.firstNode;        while (!found && (currentNode != null))        {            if (anEntry.equals(currentNode.data))                found = true;            else                currentNode = currentNode.next;        }        return currentNode;    } // end getReferenceTo    /**     * Removes all entries from this bag.     */    public void clear()    {        while (!isEmpty())            remove();    } // end clear    /**     * Removes one unspecified entry from this bag, if possible.     *     * @return either the removed entry, if the removal     * was successful, or null     */    public T remove()    {        T result = null;        if (this.firstNode != null)        {            result = this.firstNode.data;            this.firstNode = this.firstNode.next; // remove first node from chain        }        return result;    } // end remove    /**     * Removes one occurrence of a given entry from this bag, if possible.     *     * @param anElement the entry to be removed     * @return true if the removal was successful, or false otherwise     */    public boolean removeElement(T anElement)    {        boolean result = false;        Node<T> nodeN = getReferenceTo(anElement);        if (nodeN != null)        {            nodeN.data = this.firstNode.data; // replace located entry with entry in first node            this.firstNode = this.firstNode.next; // remove first node from chain            result = true;        }        return result;    } // end remove    private class Node<S>    {        private S data; // entry in bag        private Node<S> next; // link to next node        private Node(S dataPortion)        {            this(dataPortion, null);        } // end constructor        private Node(S dataPortion, Node<S> nextNode)        {            this.data = dataPortion;            this.next = nextNode;        }    } // end Node} // end LinkedBag